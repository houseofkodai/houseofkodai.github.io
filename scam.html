<!doctype html><html lang="en" class='h-100'>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>scam: samar's cam</title>
<link rel="stylesheet" href="https://unpkg.com/tachyons@4.10.0/css/tachyons.min.css"/>
<script src="https://redom.js.org/redom.min.js"></script>
</head>

<body class='h-100'>
<noscript class='bg-yellow w-100 h-100 flex justify-center items-center'>You need to enable JavaScript to use this app!</noscript>
<script>
const { el, mount, setChildren} = redom

class VideoProc {
  constructor() {
    this.oRect = {'x':0,'y':0,'w':0,'h':0};
    this.elOffScreenCanvas = document.createElement('canvas');

    this.elStatus = el('.fixed.bg-white.pa1.self-start');
    this.elSelectVideoDevice = el('select.fixed', {'style':{'display':'none'}});
    //hide-elements until camera permission has been allowed.
    this.elVideo = el('video.fixed.bg-yellow', {'style':{'display':'none'}});
    this.elOverlay = el('canvas.absolute.ba.bw1.b--blue', {'style':{'display':'none'}});
    this.el = el('.w-100.h-100.flex.justify-center.bg-black', [this.elVideo, this.elOverlay, this.elSelectVideoDevice, this.elStatus]);
    //note: if w-100 is set then overlay w/h needs to be adjusted by appropriate ratio elWidth/videoWidth elHeight/videoHeight

    window.addEventListener('resize',this.onResize,false);
    this.el.addEventListener('dblclick',this.overlayDblClick,false);
    this.elVideo.addEventListener('loadedmetadata',this.videoOnLoadedMetaData,false);

    this.frameCount = 0;
    this.startTime = 0;
    this.fps = 0;
  }
  onmount() {
    //hide-elements until camera permission has been allowed.
    navigator.mediaDevices.enumerateDevices().then((devices) => {
      //let devlist = [el('option', 'Select Camera')];
      let devlist = [];
      devices.filter((d) => d.kind === 'videoinput').forEach((k,v) => {
        devlist.push(el('option', {'value':k.deviceId}, k.label));
      });
      if (devlist.length > 1) {
        this.elSelectVideoDevice.addEventListener('change',this.selectVideoDevice,false);
        setChildren(this.elSelectVideoDevice, devlist);
        this.elSelectVideoDevice.style.display = 'block';
      } else {
        navigator.mediaDevices.getUserMedia({audio:false, video:true, deviceId: devlist[0].value})
          .then(this.onVideoOpen).catch(this.onVideoError);
      }
    });
  }
  selectVideoDevice = (evt) => {
    //ideally delete-elSelectVideoDevice - next-best-thing
    console.log('selectVideoDevice', this.elSelectVideoDevice.value, evt);
    this.elSelectVideoDevice.removeEventListener('change',this.selectVideoDevice,false);
    this.elSelectVideoDevice.style.display = 'none';
    navigator.mediaDevices.getUserMedia({audio:false, video:true, deviceId: this.elSelectVideoDevice.value})
    .then(this.onVideoOpen).catch(this.onVideoError);
  }
  onResize = (evt) => {
    //console.log('onResize', this.elVideo.videoWidth);
    this.oRect.w = Math.round(this.elVideo.videoWidth / 2);
    this.oRect.h = Math.round(this.elVideo.videoHeight / 2);
    this.elOverlay.width = this.oRect.w;
    this.elOverlay.height = this.oRect.h;
    this.elOffScreenCanvas.width = this.oRect.w;
    this.elOffScreenCanvas.height = this.oRect.h;
    this.oRect.x = this.elVideo.offsetLeft + Math.round((this.elVideo.videoWidth - this.oRect.w)/2);
    this.oRect.y = this.elVideo.offsetTop + Math.round((this.elVideo.videoHeight - this.oRect.h)/2);
    this.elOverlay.style.left = this.oRect.x + 'px';
    this.elOverlay.style.top = this.oRect.y + 'px';
  }
  statusUpdate() {
    this.elStatus.innerText = this.fps + ' ' + this.oRect.x + ',' + this.oRect.y + ' ' +
      this.oRect.w + 'x' + this.oRect.h;
  }
  overlayDblClick = (evt) => {
    if (this.elStatus.style.display != 'none') {
      this.elStatus.style.display = 'none';
      //cancelAnimationFrame(this.rafID);
    } else {
      this.elStatus.style.display = 'block';
	  //this.rafID = requestAnimationFrame(this.onFrame.bind(this));
    }
  }
  onVideoOpen = (stream) => {
    //console.log('onVideoOpen');
    this.elOverlay.style.display = 'block';
    this.elVideo.style.display = 'block';
    this.frameCount = 0;
    this.startTime = new Date().getTime();
    this.elVideo.srcObject = stream;
    this.elVideo.play();
  }
  onVideoError = (err) => {
    this.elStatus.innerText = err.name + ': Allow access to camera, and try again.';
    this.elStatus.classList.add('red');
  }
  videoOnLoadedMetaData = (evt) => {
    //console.log('videoOnLoadedMetaData', evt, this.elVideo.videoWidth, this.elVideo.videoHeight);
    this.onResize();
    this.statusUpdate();
    this.rafID = requestAnimationFrame(this.onFrame.bind(this));    
  }
  onFrame(timestamp) {
    if (this.elVideo.readyState === this.elVideo.HAVE_ENOUGH_DATA) {
      const ctxOffScreen = this.elOffScreenCanvas.getContext('2d');
      const ctxOverlay = this.elOverlay.getContext('2d');

      // Draw selected area of video to OffScreenCanvas
      ctxOffScreen.drawImage(this.elVideo, (this.oRect.x-this.elVideo.offsetLeft), (this.oRect.y-this.elVideo.offsetTop), this.oRect.w, this.oRect.h, 0, 0, this.oRect.w, this.oRect.h);

      // get the imageData from OffScreenCanvas
	  let rgba = ctxOffScreen.getImageData(0, 0, this.oRect.w, this.oRect.h);

      // grayscale magic-numbers change as reqd. 
      //from http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.html
      //const rgb2gs = [0.2125, 0.7154, 0.0721];
      const rgb2gs = [0.299, 0.587, 0.114];
      for (let i = 0; i < rgba.data.length; i += 4) {
      	let mono = (rgba.data[i] * rgb2gs[0]) + (rgba.data[i+1] * rgb2gs[1]) + (rgba.data[i+1] * rgb2gs[2]);
        rgba.data[i] = mono;
        rgba.data[i+1] = mono;
        rgba.data[i+2] = mono;
      }

      // draw modified Image on overlayCanvas
      ctxOverlay.putImageData(rgba, 0, 0);

      this.frameCount += 1;
      let elapsed = (new Date().getTime()) - this.startTime;
      this.fps = Math.round(this.frameCount*1000/elapsed);
      this.statusUpdate();
      //reset counters - so fps is for last 5 seconds
      if (elapsed > 5000) {
        this.frameCount = 0;
        this.startTime = new Date().getTime();
      }
    }
	this.rafID = requestAnimationFrame(this.onFrame.bind(this));
  }
}

class App {
  constructor() {
    if (navigator.mediaDevices && navigator.getUserMedia && window.MediaRecorder) {
      this.videoProc = new VideoProc();
      this.el = el('#app.w-100.h-100.flex.justify-center.items-center', this.videoProc);
    } else {
      this.el = el('p.bg-yellow.w-100.h-100.flex.justify-center.items-center', 'Supported/Tested browsers are Google Chrome 79+');
    }
  }
}

//const app = new App(); //if you want global app then use it - good habit not to though.
function main() {
  redom.mount(document.body, new App());
}

window.addEventListener('load', function(){setTimeout(main,0)}, false)
</script>
</body>
</html>
