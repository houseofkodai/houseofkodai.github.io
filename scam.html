<!doctype html><html lang="en" class='h-100'>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>scam: samar's cam</title>
<link rel="stylesheet" href="https://unpkg.com/tachyons@4.10.0/css/tachyons.min.css"/>
<script src="https://redom.js.org/redom.min.js"></script>
</head>

<body class='h-100'>
<noscript class='bg-yellow w-100 h-100 flex justify-center items-center'>You need to enable JavaScript to use this app!</noscript>
<script>
const { el, mount, setChildren} = redom

function hhmmss(secs) {
  let nstr = function(n) {return ((n<10)?'0':'') + n};
  if (secs >= (60*60)) {
    let rsecs = secs % 3600;
    return nstr(Math.round(secs/3600)) + nstr(Math.round(rsecs/60)) + ':' + nstr(rsecs%60);
  } else if (secs >= 60) {
    return nstr(Math.round(secs/60)) + ':' + nstr(secs%60);
  } else {
    return nstr(secs);
  }
}

class VideoProc {
  constructor() {

    this.urlParams = new URLSearchParams(window.location.search);

    this.oRect = {'x':0,'y':0,'w':0,'h':0};
    this.oRect.w = parseInt(this.urlParams.get('w') || '0') || 0;
    this.oRect.h = parseInt(this.urlParams.get('h') || '0') || 0;
    if (this.oRect.w < 0) {
      this.oRect.w = 0;
    } else if ((this.oRect.w == 0) && (this.oRect.h != 0)) {
      this.oRect.w = this.oRect.h;
    }
    if (this.oRect.h < 0) {
      this.oRect.h = 0;
    } else if ((this.oRect.h == 0) && (this.oRect.w != 0)) {
      this.oRect.h = this.oRect.w;
    }
    this.fps = parseInt(this.urlParams.get('fps') || '25') || 25;

    this.elOffScreenCanvas = document.createElement('canvas');

    this.elStatus = el('.fixed.bg-white.pa1.self-start');
    this.elSelectVideoDevice = el('select.fixed', {'style':{'display':'none'}});

    //hide-elements until camera permission has been allowed.
    //note: if elVideo is stretched to w-100 then overlay w/h needs to be adjusted by appropriate ratio elWidth/videoWidth elHeight/videoHeight
    this.elVideo = el('video.fixed.bg-yellow', {'style':{'display':'none'}});
    this.elOverlay = el('canvas.absolute.ba.bw1.b--blue', {'style':{'display':'none'}});

    this.el = el('.w-100.h-100.flex.justify-center.bg-black', [this.elVideo, this.elOverlay, this.elSelectVideoDevice, this.elStatus]);

    window.addEventListener('resize',this.onResize,false);
    this.el.addEventListener('dblclick',this.overlayDblClick,false);
    this.elVideo.addEventListener('loadedmetadata',this.videoOnLoadedMetaData,false);

    this.lastFrameTime = 0;
    this.frameInterval = Math.round(1000 / this.fps);
  }
  onmount() {
    //hide-elements until camera permission has been allowed.
    navigator.mediaDevices.enumerateDevices().then((devices) => {
      let devlist = [el('option', 'Select Camera')];
      devices.filter((d) => d.kind === 'videoinput').forEach((k,v) => {
        devlist.push(el('option', {'value':k.deviceId}, k.label));
      });
      if (devlist.length < 2) {
        this.elStatus.innerText = 'No videoinput/camera device available.';
        this.elStatus.classList.add('red');        
      } else if (devlist.length > 2) {
        this.elSelectVideoDevice.addEventListener('input',this.selectVideoDevice,false);
        setChildren(this.elSelectVideoDevice, devlist);
        this.elSelectVideoDevice.style.display = 'block';
      } else {
        navigator.mediaDevices.getUserMedia({'audio':false, 'video':{'deviceId': devlist[1].value}})
          .then(this.onVideoOpen).catch(this.onVideoError);
      }
    });
  }
  selectVideoDevice = (evt) => {
    //console.log('selectVideoDevice', this.elSelectVideoDevice.value, evt);
    if (this.elSelectVideoDevice.value != 'Select Camera') {
      navigator.mediaDevices.getUserMedia({'audio':false, 'video':{'deviceId': this.elSelectVideoDevice.value}})
      .then(this.onVideoOpen).catch(this.onVideoError);
      //no need for elSelectVideoDevice anymore
      this.elSelectVideoDevice.style.display = 'none';
      this.elSelectVideoDevice.removeEventListener('input',this.selectVideoDevice,false);
    }
  }
  onResize = (evt) => {
    //console.log('onResize', this.oRect);
    if ((this.oRect.w == 0) || 
        (this.oRect.w > this.elVideo.videoWidth) ||
        (this.oRect.h > this.elVideo.videoHeight)) {
      this.oRect.w = Math.round(this.elVideo.videoWidth / 2);
      this.oRect.h = Math.round(this.elVideo.videoHeight / 2);
    }
    if (this.oRect.w != this.elOverlay.width) {
      this.elOverlay.width = this.oRect.w;
      this.elOverlay.height = this.oRect.h;
      this.elOffScreenCanvas.width = this.oRect.w;
      this.elOffScreenCanvas.height = this.oRect.h;
    }
    this.oRect.x = this.elVideo.offsetLeft + Math.round((this.elVideo.videoWidth - this.oRect.w)/2);
    this.oRect.y = this.elVideo.offsetTop + Math.round((this.elVideo.videoHeight - this.oRect.h)/2);
    this.elOverlay.style.left = this.oRect.x + 'px';
    this.elOverlay.style.top = this.oRect.y + 'px';
  }
  overlayDblClick = (evt) => {
    if (this.elStatus.style.display != 'none') {
      this.elStatus.style.display = 'none';
      //cancelAnimationFrame(this.rafID);
    } else {
      this.elStatus.style.display = 'block';
	  //this.rafID = requestAnimationFrame(this.onFrame.bind(this));
    }
  }
  onVideoOpen = (stream) => {
    //console.log('onVideoOpen');
    this.elOverlay.style.display = 'block';
    this.elVideo.style.display = 'block';
    this.startTime = new Date().getTime();
    this.elVideo.srcObject = stream;
    this.elVideo.play();
  }
  onVideoError = (err) => {
    this.elStatus.innerText = err.name + ': Allow access to camera, and try again.';
    this.elStatus.classList.add('red');
  }
  videoOnLoadedMetaData = (evt) => {
    //console.log('videoOnLoadedMetaData', evt, this.elVideo.videoWidth, this.elVideo.videoHeight);
    this.onResize();
    this.rafID = requestAnimationFrame(this.onFrame.bind(this));    
  }
  onFrame(timestamp) {
    if ((this.elVideo.readyState === this.elVideo.HAVE_ENOUGH_DATA) &&
        ((new Date().getTime() - this.lastFrameTime) >= this.frameInterval)) {
      this.lastFrameTime = new Date().getTime();

      const ctxOffScreen = this.elOffScreenCanvas.getContext('2d');
      const ctxOverlay = this.elOverlay.getContext('2d');

      // Draw selected area of video to OffScreenCanvas
      ctxOffScreen.drawImage(this.elVideo, (this.oRect.x-this.elVideo.offsetLeft), (this.oRect.y-this.elVideo.offsetTop), this.oRect.w, this.oRect.h, 0, 0, this.oRect.w, this.oRect.h);

      // get the imageData from OffScreenCanvas
	  let rgba = ctxOffScreen.getImageData(0, 0, this.oRect.w, this.oRect.h);

      // grayscale magic-numbers change as reqd. 
      //from http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.html
      //const rgb2gs = [0.2125, 0.7154, 0.0721];
      const rgb2gs = [0.299, 0.587, 0.114];
      for (let i = 0; i < rgba.data.length; i += 4) {
      	let mono = (rgba.data[i] * rgb2gs[0]) + (rgba.data[i+1] * rgb2gs[1]) + (rgba.data[i+1] * rgb2gs[2]);
        rgba.data[i] = mono;
        rgba.data[i+1] = mono;
        rgba.data[i+2] = mono;
      }

      // draw modified Image on overlayCanvas
      ctxOverlay.putImageData(rgba, 0, 0);

      this.elStatus.innerText = hhmmss(Math.round(((new Date().getTime()) - this.startTime)/1000));
    }
	this.rafID = requestAnimationFrame(this.onFrame.bind(this));
  }
}

class App {
  constructor() {
    if (navigator.mediaDevices && navigator.getUserMedia && window.MediaRecorder) {
      this.videoProc = new VideoProc();
      this.el = el('#app.w-100.h-100.flex.justify-center.items-center', this.videoProc);
    } else {
      this.el = el('p.bg-yellow.w-100.h-100.flex.justify-center.items-center', 'Supported/Tested browsers are Google Chrome 79+');
    }
  }
}

//app is global cuz. need to debug in console
const app = new App();
function main() {
  redom.mount(document.body, app);
}

window.addEventListener('load', function(){setTimeout(main,0)}, false)
</script>
</body>
</html>
